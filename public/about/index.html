<!doctype html>
<html data-n-head="" data-n-head-ssr>
  <head>
    <meta data-n-head="true" charset="utf-8"><meta data-n-head="true" content="width=device-width,initial-scale=1" name="viewport"><meta data-n-head="true" content="Nuxt.js project" name="description" data-hid="description"><title data-n-head="true">Coyle.Blog</title><link href="/favicon.ico" rel="icon" data-n-head="true" type="image/x-icon"><link href="/_nuxt/manifest.c3f33a4a3372d0fb156e.js" rel="preload" as="script"><link href="/_nuxt/vendor.2c503f5438bffb1836dc.js" rel="preload" as="script"><link href="/_nuxt/app.a920da34d3c5de0f1628.js" rel="preload" as="script"><link href="/_nuxt/layouts_default.717c3ba0ffc1fb9978b6.js" rel="preload" as="script"><link href="/_nuxt/pages_about.63370a4dd177db925535.js" rel="preload" as="script"><link href="/_nuxt/pages_index.548c2a7def7b1747533c.js" rel="prefetch"><link href="/_nuxt/pages_article__id.c4f2ccbbf84b610f46ac.js" rel="prefetch"><style data-vue-ssr-id="39744462:0">.nuxt-progress{position:fixed;top:0;left:0;right:0;height:2px;width:0;-webkit-transition:width .2s,opacity .4s;transition:width .2s,opacity .4s;opacity:1;background-color:#efc14e;z-index:999999}</style><style data-vue-ssr-id="61aa4917:0">html{font-family:Source Sans Pro,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,sans-serif;font-size:16px;word-spacing:1px;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;-webkit-box-sizing:border-box;box-sizing:border-box}body{background-color:#fff}ul{list-style:none;margin:0;padding:0}*,:after,:before{-webkit-box-sizing:border-box;box-sizing:border-box;margin:0}.button--green{display:inline-block;border-radius:4px;border:1px solid #3b8070;color:#3b8070;text-decoration:none;padding:10px 30px}.button--green:hover{color:#fff;background-color:#3b8070}.button--grey{display:inline-block;border-radius:4px;border:1px solid #35495e;color:#35495e;text-decoration:none;padding:10px 30px;margin-left:15px}.button--grey:hover{color:#fff;background-color:#35495e}</style><style data-vue-ssr-id="2a7742b2:0">.menu{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end;-webkit-box-align:center;-ms-flex-align:center;align-items:center;height:70px;padding-right:40px}.menu li{margin-right:20px}.menu li a{text-decoration:none;color:#a1b2b4;font-size:18px;font-weight:700}</style><style data-vue-ssr-id="42d84e2c:0">.font-awesome-con{max-width:700px;margin:0 auto;padding-top:100px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.font-awesome-con a{text-decoration:none}.font-awesome-con .fa{font-size:23px;width:40px;height:40px;border-radius:22px;color:#000;background-color:#fff;border:1px solid #000;padding:5px}.font-awesome-con .fa+.fa{margin-left:15px}.font-awesome-con .fa:before{position:relative;top:6px;left:4px}</style><style data-vue-ssr-id="27ff63d4:0">.info-view{padding-top:20px;padding-bottom:20px}.avator{text-align:center}.avator img{width:80px;height:80px;border-radius:50%;border:1px solid #ddd;vertical-align:middle}.blog-name{color:#293846;text-align:center;margin-top:30px;font-size:32px;font-weight:700}.words{color:#a1b2b4;text-align:center;margin-top:10px;font-size:16px;font-weight:400;font-style:italic}</style>
  </head>
  <body data-n-head="">
    <div id="__nuxt" data-server-rendered="true"><div class="nuxt-progress" style="width:0%;height:2px;background-color:#3b8070;opacity:0"></div><div id="__layout"><div><div class="blog-header"><ul class="menu"><li><a class="nuxt-link-active" href="/">首页</a><li><a class="nuxt-link-exact-active nuxt-link-active" href="/about">关于</a></ul></div><div><div class="info-view"><div class="avator"><img alt src="/imgs/avator.jpg"></div><div class="blog-name">Coyle</div><div class="words">Chase the excellence, success will follow you.</div></div><div class="font-awesome-con"><a class="fa fa-lg fa-github" href="https://github.com/skyroom" aria-hidden="true" target="_blank"></a><a class="fa fa-lg fa-weibo" href="https://weibo.com/u/2720114643" aria-hidden="true" target="_blank"></a><a class="fa fa-lg fa-twitter" href="https://twitter.com/skyroomtui" aria-hidden="true" target="_blank"></a><a class="fa fa-lg fa-stack-overflow" href="https://stackoverflow.com/story/coyle" aria-hidden="true" target="_blank"></a></div></div></div></div></div><script type="text/javascript">window.__NUXT__={layout:"default",data:[{}],error:null,state:{articles:{articlesViewlist:[{_id:"5b8647ebdc000f3f162638a0",title:"Javascript事件循环机制以及渲染引擎何时渲染UI",short:"详细介绍Javascript事件循环机制以及渲染引擎何时渲染UI",content:">JavaScript的一大特点就是单线程，而这个线程中拥有唯一的一个事件循环。\n\n## 事件循环基本概念\n*   JavaScript代码的执行过程中，除了依靠函数调用栈来搞定函数的执行顺序外，还依靠任务队列(task queue)来搞定另外一些代码的执行。\n*   一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。\n*   任务队列又分为macro-task（宏任务）与micro-task（微任务），在最新标准中，它们被分别称为task与jobs。\n*   macro-task大概包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。\n*   micro-task大概包括: process.nextTick, Promise, Object.observe(已废弃), MutationObserver(html5新特性)\n*   setTimeout/Promise等我们称之为任务源。而进入任务队列的是他们指定的具体执行任务。\n```js\n// setTimeout中的回调函数才是进入任务队列的任务\nsetTimeout(function() {\n    console.log('xxxx');\n})\n// 非常多的同学对于setTimeout的理解存在偏差。所以大概说一下误解：\n// setTimeout作为一个任务分发器，这个函数会立即执行，而它所要分发的任务，也就是它的第一个参数，才是延迟执行\n```\n*   来自不同任务源的任务会进入到不同的任务队列。其中setTimeout与setInterval是同源的。\n*   其中每一个任务的执行，无论是macro-task还是micro-task，都是借助函数调用栈来完成。\n## 事件循环执行循序\n**事件循环的顺序，决定了JavaScript代码的执行顺序。它从script(整体代码)开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(**只剩全局**)，然后执行所有的micro-task。当所有可执行的micro-task执行完毕之后，本轮循环结束。下一轮循环再次从macro-task开始，找到其中一个任务队列执行完毕，然后再执行所有的micro-task，这样一直循环下去。**\n\n**当我们在执行setTimeout任务中遇到setTimeout时，它仍然会将对应的任务分发到setTimeout队列中去，但是该任务就得等到下一轮事件循环执行。**\n\n### 那么整个事件循环中何时进行ui render呢？\n```html\n<div id=\"div\">\n    begin\n</div>\n```\n```js\nsetTimeout(function() {\n    // 应该是这里执行前开始渲染ui，试试用alert阻塞下。\n    alert(' ui 已经渲染完毕了吗？ ');\n    console.log('timeout1');\n})\n\nnew Promise(function(resolve) {\n    console.log('promise1');\n    for(var i = 0; i < 1000; i++) {\n        i == 99 && resolve();\n    }\n    console.log('promise2');\n}).then(function() {\n    console.log('then1');\n    alert(' ui 开始渲染 ');\n})\n\nconsole.log('global1');\n\ndiv.innerHTML = 'end';\n```\n上述代码中修改了div的内容，那么在执行那句js代码之后渲染引擎开始修改div的内容呢？\n\n**根据HTML Standard，一轮事件循环执行结束之后，下轮事件循环执行之前开始进行UI render。即：macro-task任务执行完毕，接着执行完所有的micro-task任务后，此时本轮循环结束，开始执行UI render。UI render完毕之后接着下一轮循环。**\n\n在chrome浏览器中执行以上代码，控制台先输出promise1,promise2,global1,then1(micro-task任务输出)，弹出'ui 开始渲染'警告框，点击确定之后，页面中的'begin'变为'end'，再弹出警告框'ui 已经渲染完毕了吗？' ，点击确认之后再输入timeout1.\n\n##### 再来一个稍微复杂一点的例子\n```html\n<div class=\"outer\" style=\"width:200px;height:200px;background-color: #ccc\">\n    1\n    <div class=\"inner\" style=\"width:100px;height:100px;background-color: #ddd\">begin</div>\n</div>\n```\n```js\n// Let's get hold of those elements\nvar outer = document.querySelector('.outer');\nvar inner = document.querySelector('.inner');\n\nvar i = 0;\n\n// Let's listen for attribute changes on the\n// outer element\nnew MutationObserver(function() {\n    console.log('mutate');\n}).observe(outer, {\n    attributes: true\n});\n\n// Here's a click listener…\nfunction onClick() {\n    i++;\n\n    if(i === 1) {\n        inner.innerHTML = 'end';\n    }\n\n    console.log('click');\n\n    setTimeout(function() {\n        alert('锚点');\n        console.log('timeout');\n    }, 0);\n\n    Promise.resolve().then(function() {\n        console.log('promise');\n    });\n\n\n    outer.setAttribute('data-random', Math.random());\n}\n\n// …which we'll attach to both elements\ninner.addEventListener('click', onClick);\nouter.addEventListener('click', onClick);\n```\n当我们点击 inner div 时程序依次的执行顺序是：\n1.  onclick 入 JS stack\n1.  打印出 click\n2.  将 timeout 压入到 macrotask\n3.  将 promise 压入到 microtask\n4.  修改 outer 属性 data-random\n5.  将 mutate 压入到 microtask，\n5.  onclick 出 JS stack\n此时，由于用户点击事件onclick产生的macrotask执行完毕，JS stack 清空，开始执行microtask.\n1.  promise 入 JS stack\n6.  打印出 promise\n1.  promise 出 JS stack\n1.  mutate 入 JS stack\n7.  打印出 mutate\n8.  mutate 出 JS stack\n此时，microtask 执行完毕，JS stack 清空，但是由于事件冒泡，接着执行outer上的onclick事件.\n1.  onclick 入 JS stack\n1.  打印出 click\n2.  将 timeout 压入到 macrotask\n3.  将 promise 压入到 microtask\n4.  修改 outer 属性 data-random\n5.  将 mutate 压入到 microtask，\n5.  onclick 出 JS stack\n此时，由于outer上的onclick事件产生的macrotask执行完毕，JS stack 清空，开始执行microtask.\n1.  promise 入 JS stack\n6.  打印出 promise\n1.  promise 出 JS stack\n1.  mutate 入 JS stack\n7.  打印出 mutate\n8.  mutate 出 JS stack\n此时，本轮事件循环结束，UI 开始 render.\n16.  页面中inner的innerHTML变为end\n此时，UI render 完毕，开始下一轮事件循环.\n17.  timeout 入 JS stack\n17.  弹出警告 锚点.\n18.  打印出 timeout\n17.  timeout 出 JS stack\n17.  timeout 入 JS stack\n19.  弹出警告 锚点.\n20.  打印出 timeout\n17.  timeout 出 JS stack\n到此为止，整个事件执行完毕，**我们可以看到在弹出警告框之前inner的内容已经改变**。\n\n##### 那如果不是用户点击事件触发onclick，而是js触发呢？\n```js\ninner.addEventListener('click', onClick);\nouter.addEventListener('click', onClick);\ninner.click();\n```\n此时的执行顺序是：\n1. 首先是script(整体代码)入 JS stack\n1.  onclick 入 JS stack\n1.  打印出 click\n2.  将 timeout 压入到 macrotask\n3.  将 promise 压入到 microtask\n4.  修改 outer 属性 data-random\n5.  将 mutate 压入到 microtask，\n5.  onclick 出 JS stack\n此时，inner 的 onclick 已经出 JS stack，但是script(整体代码)还没有出 JS stack，还不能执行microtask，由于冒泡，接着执行 outer 的 onclick.\n1.  onclick 入 JS stack\n1.  打印出 click\n2.  将 timeout 压入到 macrotask\n3.  将 promise 压入到 microtask\n4.  修改 outer 属性 data-random\n接着执行的outer.setAttribute('data-random', Math.random());，但是由于上一个mutation microtask还处于等待状态，不能再添加mutation microtask，所以这里不会将 mutate 压入到 microtask。接着执行：\n5.  onclick 出 JS stack\n5.  script(整体代码)出 JS stack\n此时，inner.click()执行完毕，script(整体代码)已出 JS stack，JS stack 清空，开始执行mircotask.\n1.  promise 入 JS stack\n6.  打印出 promise\n1.  promise 出 JS stack\n1.  mutate 入 JS stack\n7.  打印出 mutate\n8.  mutate 出 JS stack\n1.  promise 入 JS stack\n6.  打印出 promise\n1.  promise 出 JS stack\n此时，所有的mircotask执行完毕，本轮事件循环结束，UI 开始 render.\n1.  页面中inner的innerHTML变为end\n此时，UI render 完毕，开始下一轮事件循环.\n17.  timeout 入 JS stack\n17.  弹出警告 锚点.\n18.  打印出 timeout\n17.  timeout 出 JS stack\n17.  timeout 入 JS stack\n19.  弹出警告 锚点.\n20.  打印出 timeout\n17.  timeout 出 JS stack\n到此为止，整个事件执行完毕，**我们可以看到在弹出警告框之前inner的内容已经改变**。\n\n**总结：首先执行macrotask，当js stack为空时执行microtask，接着开始UI render，接着再开始下一轮循环**\n\n参考文献：\n[深入核心，详解事件循环机制](https://segmentfault.com/a/1190000012646373)\n[Tasks, microtasks, queues and schedules](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)",createdAt:"2018-08-29 07:14:51"}],articleslist:[],article:{title:"",content:"",createdAt:""}}},serverRendered:!0}</script><script defer src="/_nuxt/manifest.c3f33a4a3372d0fb156e.js"></script><script defer src="/_nuxt/layouts_default.717c3ba0ffc1fb9978b6.js"></script><script defer src="/_nuxt/pages_about.63370a4dd177db925535.js"></script><script defer src="/_nuxt/vendor.2c503f5438bffb1836dc.js"></script><script defer src="/_nuxt/app.a920da34d3c5de0f1628.js"></script>
  

